<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>C335143_산유화</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@300;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #111;
        font-family: "Noto Serif KR", serif;
        cursor: none;
      }
      canvas {
        display: block;
      }

      #cursor {
        position: absolute;
        width: 30px;
        height: 30px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        transition: width 0.2s, height 0.2s;
        mix-blend-mode: difference;
        z-index: 10;
      }

      #guide {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        color: #555;
        font-size: 0.8rem;
        pointer-events: none;
        opacity: 0;
        animation: fadeIn 3s forwards 1s;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div id="cursor"></div>
    <div id="guide">화면을 클릭하여 형태를 변화시키세요</div>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const cursor = document.getElementById("cursor");

      let width, height;
      let particles = [];
      let mouse = { x: -1000, y: -1000 };

      const PARTICLE_COUNT = 1600;
      const FONT_SIZE = 12;

      const POEM_LINES = [
        "산에는 꽃 피네",
        "꽃이 피네",
        "갈 봄 여름 없이",
        "꽃이 피네",
        "산에 산에",
        "피는 꽃은",
        "저만치 혼자서",
        "피어 있네",
      ];

      let currentScene = 0;

      const shapeCtx = document.createElement("canvas").getContext("2d");

      function getPointsFromText(text, fontSize, isBold = false) {
        shapeCtx.canvas.width = width;
        shapeCtx.canvas.height = height;
        shapeCtx.clearRect(0, 0, width, height);

        shapeCtx.font = `${isBold ? 700 : 300} ${fontSize}px 'Noto Serif KR'`;
        shapeCtx.textAlign = "center";
        shapeCtx.textBaseline = "middle";
        shapeCtx.fillStyle = "white";
        shapeCtx.fillText(text, width / 2, height / 2);

        return scanPixels();
      }

      function getPointsFromMountain() {
        shapeCtx.canvas.width = width;
        shapeCtx.canvas.height = height;
        shapeCtx.clearRect(0, 0, width, height);

        shapeCtx.beginPath();
        shapeCtx.moveTo(0, height);
        shapeCtx.lineTo(0, height * 0.8);
        shapeCtx.bezierCurveTo(
          width * 0.2,
          height * 0.4,
          width * 0.4,
          height * 0.9,
          width * 0.5,
          height * 0.6
        );
        shapeCtx.bezierCurveTo(
          width * 0.6,
          height * 0.3,
          width * 0.8,
          height * 0.8,
          width,
          height * 0.7
        );
        shapeCtx.lineTo(width, height);
        shapeCtx.closePath();

        shapeCtx.fillStyle = "white";
        shapeCtx.fill();

        return scanPixels(8);
      }

      function getPointsFromFlower() {
        shapeCtx.canvas.width = width;
        shapeCtx.canvas.height = height;
        shapeCtx.clearRect(0, 0, width, height);

        const cx = width / 2;
        const cy = height / 2;
        const r = Math.min(width, height) * 0.25;

        shapeCtx.translate(cx, cy);
        shapeCtx.fillStyle = "white";
        for (let i = 0; i < 6; i++) {
          shapeCtx.beginPath();
          shapeCtx.ellipse(0, -r * 0.8, r * 0.5, r, 0, 0, Math.PI * 2);
          shapeCtx.fill();
          shapeCtx.rotate(Math.PI / 3);
        }
        shapeCtx.beginPath();
        shapeCtx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
        shapeCtx.fill();
        shapeCtx.setTransform(1, 0, 0, 1, 0, 0);

        return scanPixels(6);
      }

      function scanPixels(gap = 4) {
        const imageData = shapeCtx.getImageData(0, 0, width, height).data;
        const points = [];
        for (let y = 0; y < height; y += gap) {
          for (let x = 0; x < width; x += gap) {
            const index = (y * width + x) * 4;
            if (imageData[index + 3] > 128) {
              points.push({ x, y });
            }
          }
        }
        return points;
      }

      class Particle {
        constructor() {
          this.x = Math.random() * width;
          this.y = Math.random() * height;
          this.tx = this.x;
          this.ty = this.y;

          this.vx = 0;
          this.vy = 0;
          const chars = ["산", "꽃", "새", "ㆍ", "¸", "˝"];
          this.text = chars[Math.floor(Math.random() * chars.length)];

          this.size = Math.random() * FONT_SIZE + 8;
          this.color = "#444";
        }

        update() {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const force = 100;

          if (dist < force) {
            const angle = Math.atan2(dy, dx);
            const push = (force - dist) / force;
            this.vx -= Math.cos(angle) * push * 2;
            this.vy -= Math.sin(angle) * push * 2;
          }

          this.vx += (this.tx - this.x) * 0.05;
          this.vy += (this.ty - this.y) * 0.05;

          this.vx *= 0.85;
          this.vy *= 0.85;

          this.x += this.vx;
          this.y += this.vy;
        }

        draw() {
          ctx.fillStyle = this.color;
          ctx.font = `${this.size}px 'Noto Serif KR'`;
          ctx.fillText(this.text, this.x, this.y);
        }
      }

      function setTargetShape(points, type) {
        const shuffledPoints = points.sort(() => 0.5 - Math.random());

        particles.forEach((p, i) => {
          const point = shuffledPoints[i % shuffledPoints.length];
          p.tx = point.x;
          p.ty = point.y;

          if (type === "flower") {
            p.text = Math.random() > 0.7 ? "꽃" : "花";
            p.color = Math.random() > 0.5 ? "#e63946" : "#ff99ac";
          } else if (type === "mountain") {
            p.text = Math.random() > 0.8 ? "산" : "山";
            p.color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.2})`;
          } else {
            p.text = Math.random() > 0.9 ? "ㆍ" : p.text;
            p.color = "#eee";
          }
        });
      }

      function nextScene() {
        currentScene++;
        let points = [];
        let type = "";

        if (currentScene === 1) {
          points = getPointsFromMountain();
          type = "mountain";
        } else if (currentScene === 2) {
          points = getPointsFromFlower();
          type = "flower";
        } else {
          const poemIdx = currentScene - 3;
          if (poemIdx < POEM_LINES.length) {
            points = getPointsFromText(POEM_LINES[poemIdx], 100, true);
            type = "text";
          } else {
            currentScene = 0;
            points = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
              points.push({
                x: Math.random() * width,
                y: Math.random() * height,
              });
            }
            type = "chaos";
          }
        }

        setTargetShape(points, type);
      }

      function init() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;

        particles = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          particles.push(new Particle());
        }

        currentScene = 0;
        const startPoints = getPointsFromMountain();
        setTargetShape(startPoints, "mountain");
      }

      function animate() {
        ctx.fillStyle = "rgba(17, 17, 17, 0.3)";
        ctx.fillRect(0, 0, width, height);

        particles.forEach((p) => {
          p.update();
          p.draw();
        });

        cursor.style.left = mouse.x + "px";
        cursor.style.top = mouse.y + "px";

        requestAnimationFrame(animate);
      }

      window.addEventListener("resize", () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      });

      window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      window.addEventListener("mousedown", () => {
        nextScene();

        cursor.style.transform = "translate(-50%, -50%) scale(1.5)";
        cursor.style.borderColor = "#fff";
        setTimeout(() => {
          cursor.style.transform = "translate(-50%, -50%) scale(1)";
          cursor.style.borderColor = "rgba(255,255,255,0.3)";
        }, 150);
      });

      window.addEventListener(
        "touchstart",
        (e) => {
          mouse.x = e.touches[0].clientX;
          mouse.y = e.touches[0].clientY;
          nextScene();
        },
        { passive: false }
      );

      init();
      animate();
    </script>
  </body>
</html>
